<!DOCTYPE html>
<html>
<body>
<script>

var Direction = {
   UP: 1,
   DOWN: 2,
   LEFT: 3,
   RIGHT: 4
};

// Possible directions it is possible to go to from a given cell
var CellNeighbors = {
   UNDEFINED: 0,
   UP: 1,
   DOWN: 1 << 1,
   LEFT: 1 << 2,
   RIGHT: 1 << 3
}

var cellSize = 10, cellSpacing = 2, numCellsHorizontally = 10, numCellsVertically = 5;
var context = initCanvas(cellSize, cellSpacing, numCellsHorizontally, numCellsVertically);

var numCells = numCellsHorizontally*numCellsVertically;
var cells = []; // Bookkeeping for the cells which were added to the minimum spanning tree
for(i=0; i<numCells; ++i)
   cells[i] = {is_in_tree: false, neighbors: CellNeighbors.UNDEFINED, marked: false};
var frontier = minHeap(function(a, b) { return a.weight-b.weight;});

// Keeps track of the current position of the player in the maze
var current_x = 0, current_y = 0;

// Perform Prim's algorithm on a grid in which each edge has a random weight, and each vertex is connected to the vertices up, down, left and right
// The maze is built from the top left hand corner

drawCell(context, 0, 0, "#FF0000");
frontier.push({x:0, y:0, direction: Direction.UP, weight:0});
cells[0].is_in_tree = true;
cells[0].marked = true;

var k = 0;
while(k < numCells) { 
   if(frontier.empty())
      break;
   // Retrieve the closest vertex to the partial spanning tree and add it to the second.
   var currentCell = frontier.pop();
   if(k>0 && cells[indexInCells(currentCell.x, currentCell.y)].is_in_tree)	// Skip nodes which have already been added to the spanning tree
      continue;
   // Add the neighbours of the current vertex with random edge weights to the frontier of the spanning tree.
   if(currentCell.x-1 >= 0 && !cells[indexInCells(currentCell.x-1, currentCell.y)].is_in_tree)
      frontier.push({x: currentCell.x-1, y: currentCell.y, direction: Direction.LEFT, weight: Math.random()});
   if(currentCell.x+1 < numCellsHorizontally && !cells[indexInCells(currentCell.x+1, currentCell.y)].is_in_tree)
      frontier.push({x: currentCell.x+1, y: currentCell.y, direction: Direction.RIGHT, weight: Math.random()});
   if(currentCell.y-1 >= 0 && !cells[indexInCells(currentCell.x, currentCell.y-1)].is_in_tree)
      frontier.push({x: currentCell.x, y: currentCell.y-1, direction: Direction.UP, weight: Math.random()});
   if(currentCell.y+1 < numCellsVertically && !cells[indexInCells(currentCell.x, currentCell.y+1)].is_in_tree)
      frontier.push({x: currentCell.x, y: currentCell.y+1, direction: Direction.DOWN, weight: Math.random()});
  
   if(k>0) {
      // Draw the next portion of the maze
      switch(currentCell.direction) {
         case Direction.UP:
            drawCellUp(context, currentCell.x, currentCell.y+1);
			cells[indexInCells(currentCell.x, currentCell.y+1)].neighbors |= CellNeighbors.UP;
			cells[indexInCells(currentCell.x, currentCell.y)].neighbors |= CellNeighbors.DOWN;
            break;
         case Direction.DOWN:
            drawCellDown(context, currentCell.x, currentCell.y-1);
			cells[indexInCells(currentCell.x, currentCell.y-1)].neighbors |= CellNeighbors.DOWN;
			cells[indexInCells(currentCell.x, currentCell.y)].neighbors |= CellNeighbors.UP;
            break;
         case Direction.LEFT:
            drawCellLeft(context, currentCell.x+1, currentCell.y);
			cells[indexInCells(currentCell.x+1, currentCell.y)].neighbors |= CellNeighbors.LEFT;
			cells[indexInCells(currentCell.x, currentCell.y)].neighbors |= CellNeighbors.RIGHT;
            break;
         case Direction.RIGHT:
            drawCellRight(context, currentCell.x-1, currentCell.y);
			cells[indexInCells(currentCell.x-1, currentCell.y)].neighbors |= CellNeighbors.RIGHT;
			cells[indexInCells(currentCell.x, currentCell.y)].neighbors |= CellNeighbors.LEFT;
            break;
      }
	  // Mark the node as being in the spanning tree
	  cells[indexInCells(currentCell.x, currentCell.y)].is_in_tree = true;
   }

   ++k;
}

window.addEventListener('keyup', keyUpHandler, true);

function keyUpHandler(event){
   var key=event.keyCode;
   switch(key) {
      case 37:
	     if(cells[indexInCells(current_x, current_y)].neighbors & CellNeighbors.LEFT) {
		    drawCellLeft(context, current_x, current_y, "#FF0000");
			current_x -= 1;
         }
	     break;
	  case 38:
	     if(cells[indexInCells(current_x, current_y)].neighbors & CellNeighbors.UP) {
		    drawCellUp(context, current_x, current_y, "#FF0000");
			current_y -= 1;
         }
	     break;
	  case 39:
	     if(cells[indexInCells(current_x, current_y)].neighbors & CellNeighbors.RIGHT) {
		    drawCellRight(context, current_x, current_y, "#FF0000");
			current_x += 1;
         }
	     break;
	  case 40:
	     if(cells[indexInCells(current_x, current_y)].neighbors & CellNeighbors.DOWN) {
		    drawCellDown(context, current_x, current_y, "#FF0000");
			current_y += 1;
         }
	     break;
   }
}

function initCanvas(cellSize, cellSpacing, numCellsHorizontally, numCellsVertically) {
   var canvas = document.createElement('canvas');
   canvas.id     = "Labyrinth";
   canvas.width  = numCellsHorizontally * (cellSize + cellSpacing) - cellSpacing;
   canvas.height = numCellsVertically * (cellSize + cellSpacing) - cellSpacing;
   canvas.style.position = "absolute";
   canvas.style.border   = "1px solid";
   canvas.setAttribute('tabindex','1');
   var c = document.body.appendChild(canvas);
   var context = c.getContext("2d");
   context.font = '18pt Calibri';
   return context;
}

function indexInCells(x, y) {
   return y * numCellsHorizontally + x;
}

// x, y cell coordinates defined from the top left corner (0, 0)
function drawCell(context, x, y, color) {
   if(typeof(color) === 'undefined') color = "#000000";
   context.fillStyle = color;
   context.fillRect(x*(cellSize+cellSpacing),y*(cellSize+cellSpacing),cellSize,cellSize);
}

// x, y cell coordinates defined from the top left corner (0, 0)
// Draws a cell above the cell at (x, y) and fill in the space between the cells (x, y) and (x, y+1)
function drawCellDown(context, x, y, color) {
   if(typeof(color) === 'undefined') color = "#000000";
   context.fillStyle = color;
   context.fillRect(x*(cellSize+cellSpacing),(y+1)*(cellSize+cellSpacing)-cellSpacing,cellSize,cellSize+cellSpacing);
}

// x, y cell coordinates defined from the top left corner (0, 0)
// Draws a cell below the cell at (x, y) and fill in the space between the cells (x, y) and (x, y-1)
function drawCellUp(context, x, y, color) {
   if(typeof(color) === 'undefined') color = "#000000";
   context.fillStyle = color;
   context.fillRect(x*(cellSize+cellSpacing),(y-1)*(cellSize+cellSpacing),cellSize,cellSize+cellSpacing);
}

// x, y cell coordinates defined from the top left corner (0, 0)
// Draws a cell on the left of the cell at (x, y) and fill in the space between the cells (x, y) and (x-1, y)
function drawCellLeft(context, x, y, color) {
   if(typeof(color) === 'undefined') color = "#000000";
   context.fillStyle = color;
   context.fillRect((x-1)*(cellSize+cellSpacing),y*(cellSize+cellSpacing),cellSize+cellSpacing,cellSize);
}

// x, y cell coordinates defined from the top left corner (0, 0)
// Draws a cell on the right of the cell at (x, y) and fill in the space between the cells (x, y) and (x+1, y)
function drawCellRight(context, x, y, color) {
   if(typeof(color) === 'undefined') color = "#000000";
   context.fillStyle = color;
   context.fillRect((x+1)*(cellSize+cellSpacing)-cellSpacing,y*(cellSize+cellSpacing),cellSize+cellSpacing,cellSize);
}

function minHeap(compare) {
  var heap = {},
      array = [],
      size = 0;
 
  heap.empty = function() {
    return !size;
  };
 
  heap.push = function(value) {
    up(array[size] = value, size++);
    return size;
  };
 
  heap.pop = function() {
    if (size <= 0) return;
    var removed = array[0], value;
    if (--size > 0) value = array[size], down(array[0] = value, 0);
    return removed;
  };
  
  heap.size = function() {
      return size;
  }
 
  function up(value, i) {
    var current_index = i;
    while (current_index > 0) {
      var parent_index = ((current_index - 1) >> 1),
          parent = array[parent_index];
      if (compare(value, parent) >= 0) break;
      array[current_index] = parent;
      current_index = parent_index;
    }
    array[current_index] = value
  }
 
  function down(value, i) {
    var parent = i;
    while (true) {
      var right = (parent + 1) << 1,
          left = right - 1,
          min = array[parent],
		  index_to_swap = parent;
      if (left < size && compare(array[left], min) < 0) min = array[index_to_swap = left];
      if (right < size && compare(array[right], min) < 0) min = array[index_to_swap = right];
      if (index_to_swap === parent) break;
      array[index_to_swap] = min;
	  array[parent] = value;
	  parent = index_to_swap;
    }	
  }
 
  return heap;
}
</script>
</body>
</html>
